%=== Тип документа - статья, кегль 14пт.
\documentclass[14pt]{article}
%=== Настройка кодировок, шрифта и языка
\usepackage[utf8]{inputenc}
\usepackage{textcase}
\usepackage{extsizes}
\usepackage[main=russian, english]{babel}
\usepackage[T2A, T1]{fontenc}

%=== Разметка документа
\usepackage{geometry} 
\geometry{
	a4paper, 
	top = 2cm,
	bottom = 2cm,
	left = 3cm,
	right = 1cm
}
%=== Форматирование текста
\usepackage {setspace}			% Интерлиньяж
\onehalfspacing					% 1.5 строки
\usepackage {indentfirst} 		% Красная строка с первого предложения
\setlength						% Отступ красной строки - 1.25см
	{\parindent}
	{1.25cm}	
\usepackage {titlesec}			% Форматирование заголовков
\titleformat					% Разделы
	{\section}
	[hang]
	{\normalfont\bfseries\centering}
	{\arabic{section}. }
	{0pt}
	{}
\titlespacing
	{\section}
	{\parindent}
	{4ex}
	{0pt}
\titleformat					% Подразделы
	{\subsection}
	[hang]
	{\normalfont\bfseries\itshape}
	{ \arabic{section}.\arabic{subsection}. }
	{0pt}
	{}
\titlespacing
	{\subsection}
	{\parindent}
	{4ex}
	{0pt}
	
\newcommand{\anonsection}[1]{\section*{#1}\addcontentsline{toc}{section}{#1}}
%=== Минимизируем количество переносов
\usepackage {ragged2e}
\usepackage {microtype}
\tolerance = 500
\hyphenpenalty = 20000
\emergencystretch = 1cm
%=== Таблицы
\usepackage {tabularx}	% основной тип таблиц, выравнивание по ширине
\usepackage {longtable}	% для таблиц, не вмещающихся на одну страницу
\usepackage {multirow}	% для разбиения ячеек на несколько строк
\usepackage {multicol}	% на несколько колонок
%=== ^ до этого места - минимальная преамбула документа.
%=== Далее идут опциональные, но часто использущиеся пакеты,
%=== а так же написанные мной команды, чем-то упрощающие написание отчетов

%=== Работа с формулами
% Набор пакетов, сильно расширяющих возможности по набору формул
\usepackage{amsmath}
% добавляет специфические для русских  статей мат. символы вроде \leqslant
\usepackage{amssymb}
% добавляет окружения для теорем и лемм	
\usepackage{amsthm}				
\usepackage{mathtools}
\newcommand{\Mod}[1]{\ (\mathrm{mod}\ #1)}
% номера только для тех формул, на которые есть ссылки в тексте
\mathtoolsset{showonlyrefs=true}
%=== Работа с изображениями
\usepackage{graphicx}
\usepackage{svg}
%=== Работа с гиперссылками
\usepackage[unicode]{hyperref}
\hypersetup{
	colorlinks=true,
	urlcolor=blue,
	filecolor=green,
	linkcolor=red
}

\begin{document}
	\include{tex/title} % титульный лист
	\include{tex/task} % задание
	\include{tex/summary} % аннотация
	\tableofcontents 
	
	\newpage
	\anonsection{Введение}
	
Любое устройство, выполняющее вычисления, основано на каком-либо физическом процессе. До ЭВМ вычисления выполнялись механическими системами. Потом появились устройства, основанные на электромагнитных реле, радиолампах, транзисторах. Каждый последующий тип устройства был эффективнее предыдущего, поэтому естественно было бы ожидать появления новых, еще более эффективных ЭВМ. Вместе с устройствами эволюционировали и алгоритмы. В 1936 году Алан Тьюринг предложил математическую модель вычислений, названную впоследствии машиной Тьюринга.
Модель Тьюринга формализовала понятие алгоритма (способа вычисления некоторой функции на физическом устройстве), что позволило ввести понятие вычислимости и в дальнейшем - понятие сложности вычислений. Тогда же, в 1936 году, Тьюринг показал, что существуют невычислимые (undecidable) функции - такие функции, которые можно формально определить, но для вычисления которых невозможно предложить алгоритм. 
Понятие сложности вычислений (количества ресурсов, необходимых для выполнения алгоритма) позволило выделить классы задач, названных неразрешимыми (intractable). В отличие от невычислимых функций, для них существуют алгоритмы, работающие за конечное время. Однако ресурсы, необходимые для вы полнения этих алгоритмов, растут слишком быстро (например, экспоненциально) с увеличением размера входных данных. С появлением неразрешимых задач возникла потребность в физических устройствах, вычислительные возможности которых зависели бы экспоненциально от размеров (ресурсов) устройства.
В 1981 году нобелевский лауреат по физике Ричард Фейнман предложил построить вычислительное устройство на основе квантовой системы. Оптимизм Фейнмана был основан на том, что простейшая квантовая система намного сложнее простейшей классической системы. Кроме того, линейным ростом квантовой системы вызывается экспоненциальный рост сложности ее описания. Например, для классического описания состояния 10-кубитной системы потребуется 1024 комплексных числа, а для 30 кубит - более миллиарда комплексных чисел.
Уже в 1985 году Дэвид Дойч разработал математическую модель универсального квантового компьютера и показал некоторые ее преимущества перед классической моделью. А в 1994-м Питер Шор взорвал научную общественность, опубликовав полиномиальный квантовый алгоритм разложения составного числа на множители. Результат Шора поставил под угрозу широко используемый алгоритм ассиметричного шифрования RSA.
RSA - ассиметричный алгоритм шифрования, названный по первым
буквам фамилий его авторов - Rivest, Shamir, Adleman.
Таким образом, квантовые вычисления имеют все шансы превзойти современные классические компьютеры сразу по двум направлениям: 1) как более совершенный, быстрый и информационно емкий физический процесс, 2) как более перспективная в теоретическом смысле модель. Репертуар квантового компьютера шире, чем у классической машины Тьюринга (которая не может, например, генерировать случайные числа), а для многих сложных для классических вычислений задач уже существуют эффективные квантовые алгоритмы.

	
	\newpage
	\section{Математическая модель квантовых вычислений}
	\subsection{Кубит}
	
	Ключевым понятием всей теории квантовых вычислений является «кубит» — сокращение термина «квантовый бит» (quantum bit) — минимальная информационная единица квантового мира. Так же как бит является частичкой информации, содержащейся в простейшем содержательном классическом вычислительном процессе, кубит является описанием простейшей содержательной квантовой системы.
	
Кубит — это вектор единичной длинны в двумерном гильбертовом пространстве над полем комплексных чисел.
	
	\begin{equation}
	|\phi \rangle \in H, ||\phi|| = 1, dimH = 2;	
	\end{equation}
	
	В гильбертовых пространствах определено скалярное произведение векторов, а значит в можно определить понятие угла $\theta$ между векторами:

	\begin{equation}
	\theta = arccos \frac{ | \langle x|y \rangle | }{||x|| \cdot ||y||}, \theta \in [0, \frac{\pi}{2}];
	\end{equation}

	Выделим в этом пространстве некоторый базис, вектора которого обозначим как $|0 \rangle$ и $|1 \rangle$. Внутри скобок записывается индекс базисного вектора в двоичной системе счисления, начиная с нуля без дополнительных символов.

	\begin{equation}
	|0 \rangle = \begin{bmatrix} 1 \\ 0 \end{bmatrix}, 
	|1 \rangle = \begin{bmatrix} 0 \\ 1 \end{bmatrix};
	\end{equation}

	Тогда произвольный вектор $\phi$ можно выразить следующим образом:
	
	\begin{equation}
	| \phi \rangle = \alpha |0 \rangle + \beta	|1 \rangle,
	\end{equation}
	
	где $\alpha$ и $\beta$ - некоторые комплексные числа, такие что $|\alpha|^2 + |\beta|^2 = 1$
	
	\newpage
	\subsection{Система кубитов}	
	
	В подавляющем большинстве случаев для вычислений требуется более одного бита. Система, состоящая из нескольких кубитов, описывается тензорным произведением составляющих ее систем. Например, квантовый регистр из 2 кубитов будет описываться пространством $H^4$ и иметь 4 базисных состояния.
	
	\begin{equation}
	|00 \rangle = |0 \rangle \otimes |0 \rangle = \begin{bmatrix} 1 \\ 0 \\ 0 \\ 0 \end{bmatrix}
	\end{equation}
	\begin{equation}
	|01 \rangle = |0 \rangle \otimes |1 \rangle = \begin{bmatrix} 0 \\ 1 \\ 0 \\ 0 \end{bmatrix}
	\end{equation}
	\begin{equation}
	|10 \rangle = |1 \rangle \otimes |0 \rangle = \begin{bmatrix} 0 \\ 0 \\ 1 \\ 0 \end{bmatrix}
	\end{equation}
	\begin{equation}
	|11 \rangle = |1 \rangle \otimes |1 \rangle = \begin{bmatrix} 0 \\ 0 \\ 0 \\ 1 \end{bmatrix}
	\end{equation}
	
	Таким образом, система из 3 кубитов описывается вектором в 8-мерном пространстве, а размерность пространства системы из 10 кубитов равна 1024. Для 1000 кубитов мы получаем пространство, размерность которого описывается числом с 300 нулями.
Построив компьютер на всего лишь 1000 атомов, мы получаем в свое распоряжение машину, состояние которой описывается 1030 комплексными числами.
	
	\newpage
	\subsection{Эволюция квантовой системы}
	
	Эволюция квантовой системы унитарна, т.е. любое изменение
ее состояния выражается действием унитарного оператора. Поскольку изменение состояния и есть вычисление, то и программа для квантового компьютера представляет собой последовательное применение различных унитарных операторов к вектору состояния.
Оператор $U$ унитарен, если его сопряженный оператор совпадает с обратным:

	\begin{equation}
	UU^* = U^*U = I
	\end{equation}
	
	Матрица сопряженного оператора представляет собой
транспонированную матрицу исходного оператора, все числа
в которой заменены на сопряженные.
Необходимым и достаточным условием унитарности оператора является сохранение им при отображении длин векторов и углов между ними:

	\begin{equation}
	\forall \phi \in H \text{    } || U|\phi \rangle || = || \phi \rangle ||,
	\end{equation}
	\begin{equation}
	\forall \phi, \psi \in H \text{    } | \langle U|\phi \rangle | U|\psi \rangle \rangle | = | \langle \phi | \psi \rangle |,
	\end{equation}
	
	Несколько примеров наиболее встречающихся операторов:
	
	\textit{Оператор Адамара}:
	\begin{equation}
	H = \frac{1}{\sqrt{2}} \begin{bmatrix} 1 & 1 \\ 1 & -1 \end{bmatrix}
	\end{equation}

	\textit{Гейт X}:
	\begin{equation}
	X = \begin{bmatrix} 0 & 1 \\ 1 & 0 \end{bmatrix}
	\end{equation}	
	
	\textit{Гейт CNOT}:
	\begin{equation}
	X = \begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 1 & 0 \end{bmatrix}
	\end{equation}	

	\newpage
	
	Также для алгоритма Шора нам потребуется квантовый оператор — квантовое преобразование Фурье (Quantum Fourier Transform, QFT):	

	\textit{Квантовое преобразование Фурье}
	\begin{equation}
		N := 2^n
	\end{equation}
	\begin{equation}
		QFT|x \rangle = \frac{||x||}{2^{n/2}} \sum_{y = 0}^{2^n-1}{e^{2 \pi i \frac{xy}{N}}} |y \rangle
	\end{equation}
	
	\newpage
	\subsection{Алгоритм квантовой оценки фазы}
	
	Фурье-преобразование является основой для общей процедуры, известной как оценка фазы (phase estimation), которая является ключевой для многих квантовых алгоритмов. Пусть есть унитарный оператор $U$, имеющий собственный вектор $|U \rangle$ и собственное число
$exp(2 \pi i \phi)$, где $\phi$ - неизвестно. Задача алгоритма оценки фазы состоит в вычислении $\phi$.

Квантовая процедура оценки фазы использует два регистра. Первый регистр содержит $t$ кубит первоначально находящихся в состоянии $|0 \rangle$. Второй регистр начинается с состояния $|U \rangle$ и содержит столько кубит, сколько необходимо чтобы собрать $|U \rangle$.	

Алгоритм состоит из трех частей.

Первая часть состоит в использовании гейта Адамара с последующим применением
controlled-U - операций на второй регистр, с U увеличенным до степени 2.

Второй шаг вычисления фазы состоит в применении обратного квантового Фурье-преобразования для первого регистра. Оно образуется путем обращения цепи квантового Фурье-преобразования. 

Третий и окончательный шаг есть чтение состояния первого регистра. 

Схематично весь алгоритм определяется квантовой цепью:

	\begin{figure}[h!]
		\centering
		\includegraphics[scale=1.5]{phase}
		\caption{Схема алгоритма квантовой оценки фазы}
	\end{figure}

Процедура оценки фазы может быть использована для решения ряда задач, в число которых входит поиск периода.
	
	\newpage
	\section{Алгоритм Шора}	
	\subsection{Проблема факторизации}
	Факторизацией натурального числа называется его разложение в произведение простых множителей. Существование и единственность (с точностью до порядка следования множителей) такого разложения следует из основной теоремы арифметики.

В отличие от задачи распознавания простоты числа, факторизация предположительно является вычислительно сложной задачей. В настоящее время неизвестно, существует ли эффективный алгоритм факторизации целых чисел. Даже самым современным алгоритмам требуется экспоненциальное время, чтобы найти коэффициенты целого числа. Это означает, что с достаточно большими числами решить эту задачу практически невозможно, несмотря на огромную вычислительную мощность. Однако доказательства того, что не существует решения этой задачи за полиномиальное время, также нет.

Предположение о том, что для больших чисел задача факторизации является вычислительно сложной, лежит в основе широко используемых алгоритмов (например, RSA).

В 1994 году Питер Шор теоретизировал алгоритм квантовых вычислений с полиномиальным временем для целочисленной факторизации. Алгоритм Шора использует как классические, так и квантовые (определение периода) вычисления. Однако преобладающая оптимизация алгоритма Шора обусловлена эффективностью квантового преобразования Фурье и модульным возведением в степень путем многократного возведения в квадрат.

Алгоритм Шора, используя возможности квантовых компьютеров, способен произвести факторизацию числа не просто за полиномиальное время, а за время, не намного превосходящее время умножения целых чисел (то есть практически так же быстро, как происходит само шифрование).Таким образом, реализация масштабируемого квантового компьютера поставит крест на большей части современной криптографической защиты. Речь не только о схеме RSA, прямо опирающейся на сложности факторизации, но и о других сходных схемах, которые квантовый компьютер способен взломать аналогичным образом.

Важно отметить, что алгоритм Шора имеет вероятностный характер. Первый источник случайности встроен в классическое вероятностное сведение разложения на множители к нахождению периода некоторой функции. Второй источник появляется из необходимости наблюдения квантовой памяти, которое также даёт случайные результаты.
	
	\newpage
	\subsection{Поиск периода и факторизация}
	Алгоритм Шора предназначен для поиска неизвестного периода некоторой периодической функции.
	Как это позволит раскладывать числа на множители?
	
	Пусть $p$ и $q$ - различные простые числа и $N = pq$. Для некоторого числа $a < N: (a, N) = 1$ определим функцию $f_a(x)$:
	
	\begin{equation}
		f_a(x) = a^x \Mod{N}
	\end{equation}
	
	Функция $f_a$ переодическая, и ее период $r$ является порядком числа $a$ в кольце $\mathbb{Z_N}$:
	\begin{equation}
		a^r = 1 \Mod{N}
	\end{equation}
	\begin{equation}
		\forall r_1 < r \text{ } a^{r_1} \neq 1 \Mod{N}
	\end{equation}
	
	Если в нашем распоряжении есть устройство, умеющее находить период любой периодической функции, то при помощи этого устройства, выбрав случайным образом число $a$, мы можем найти период $r$ функции $f_a$.
	
	Допустим, число $r$ - четное. Тогда выражение
	\begin{equation}
		a^r - 1 = 0 \Mod{N}
	\end{equation}
	мы можем представить в виде 
	\begin{equation}
		(a^{r/2} - 1)(a^{r/2} + 1) = Nk
	\end{equation}
	
	Число $(a^{r/2} - 1)$ не делится на $N$, так как иначе $a^{r/2}$ было
бы сравнимо с $0$ по модулю $N$, и число $r/2$ было бы периодом.	
	
	Допустим также, что
	\begin{equation}
		(a^{r/2} + 1) \neq 0 \Mod{N}
	\end{equation}
	
	Тогда произведение $(a^{r/2} - 1)(a^{r/2} + 1)$ делится на $N$, но 
ни один из множителей $(a^{r/2} - 1)$, $(a^{r/2} + 1)$ не делится на $N$
целиком. Следовательно, числа $(a^{r/2} - 1)$, $(a^{r/2} + 1)$ не взаимно
просты с $N$, и мы можем найти $p$ и $q$ при помощи алгоритма Евклида:
	\begin{equation}
		p, q = GCD(a^{r/2} \pm 1, N);
	\end{equation}

	В ходе рассуждения мы сделали два допущения. C какой вероятностью для наугад выбранного числа $a$ его порядок $r$ удовлетворяет этим условиям? Оказывается, что вероятность неудачи сведения задачи факторизации к задаче поиска периода при выборе числа $a$ небольше 1/2.
	
	\newpage
	\subsection{Квантовый алгоритм Шора}
	
	Квантовый алгоритм Шора решает проблему нахождения периода следующей функции:
	\begin{equation}
		f(x) = a^x \Mod{N}
	\end{equation}
	
	Решение Шора заключалось в использовании квантовой оценки фазы унитарного оператора:
	\begin{equation}
		U|y \rangle \equiv |ay \text{ } mod \text{ } N \rangle
	\end{equation}
	
	Чтобы увидеть, насколько это полезно, давайте разберемся, как может выглядеть собственное состояние $U$. Если мы начали в состоянии $|1 \rangle$, мы увидим, что каждое последующее применение $U$ будет умножать состояние нашего регистра на $a \Mod{N}$, и после $r$ применений мы снова придем к состоянию $|1 \rangle$. Таким образом, суперпозиция состояний в этом цикле $(|u_0 \rangle)$ будет собственным состоянием $U$:
	\begin{equation}
		|u_0 \rangle = \frac{1}{\sqrt{r}} \sum_{k=0}^{r-1} |a^k \text{ } mod \text{ } N \rangle
	\end{equation}
	
	Это собственное состояние имеет собственное значение 1, что не очень интересно. Более интересным собственным состоянием могло бы быть такое, в котором фаза различна для каждого из этих вычислительных базисных состояний. В частности, давайте рассмотрим случай, когда фаза $k$-го состояния пропорциональна $k$:
	 \begin{equation}
		|u_1 \rangle = \frac{1}{\sqrt{r}} \sum_{k=0}^{r-1} e^{-\frac{2 \pi i k}{r}} |a^k \text{ } mod \text{ } N \rangle
	\end{equation}
	\begin{equation}
		U|u_1 \rangle = e^{\frac{2 \pi i}{r}} |u_1 \rangle
	\end{equation}
	
	Это особенно интересное собственное значение, поскольку оно содержит $r$. Это не единственное собственное состояние с таким поведением; чтобы обобщить это дальше, мы можем умножить целое число $s$ на эту разность фаз, которая будет отображаться в нашем собственном значении: 
	 \begin{equation}
		|u_s \rangle = \frac{1}{\sqrt{r}} \sum_{k=0}^{r-1} e^{-\frac{2 \pi i k s}{r}} |a^k \text{ } mod \text{ } N \rangle
	\end{equation}
	\begin{equation}
		U|u_s \rangle = e^{\frac{2 \pi i s}{r}} |u_s \rangle
	\end{equation}
	
	Теперь у нас есть уникальное собственное состояние для каждого целого значения $0 \le s 
	\le r - 1$.
	
	Eсли мы суммируем все эти собственные состояния, разные фазы сокращают все вычислительные базисные состояния, кроме $|1 \rangle$
	\begin{equation}
		 \frac{1}{\sqrt{r}} \sum_{s=0}^{r-1} |u_s \rangle  = |1 \rangle
	\end{equation}
	
	Поскольку вычислительное базисное состояние $|1 \rangle$ является суперпозицией этих собственных состояний, это означает, что если мы выполняем QPE на $U$, используя состояние $|1\rangle$, мы будем измерять фазу:
	\begin{equation}
		 \phi = \frac{s}{r},
	\end{equation}
	где $s$ случайное число между 0 и $r - 1$. Наконец, мы используем алгоритм цепных дробей на $\phi$, чтобы найти $r$. Принципиальная схема выглядит следующим образом:
	\begin{figure}[h!]
		\centering
		\includegraphics[scale=0.5]{shor_circuit_1}
		\caption{Схема алгоритма Шора}
	\end{figure}

	
	\newpage
	\subsection{Реализация алгоритма}
	
	Алгоритм был реализован на языке python с использованием библиотеки qiskit.Рассмотрим некоторые части. 
	
			
	Функция \verb|c_amod15| - контроллирующий гейт преобразования $a^x mod N$. В примере мы использовали $a=7$ и $N=15$.
	
	\begin{verbatim}
def c_amod15(power):
    U = QuantumCircuit(4)
    for iteration in range(power):
            U.swap(2,3)
            U.swap(1,2)
            U.swap(0,1)
            for q in range(4):
                U.x(q)
    U = U.to_gate()
    U.name = "7^%i mod 15" % power
    c_U = U.control()
    return c_U
	\end{verbatim}
	
	Функция \verb|inversed_qft| - обраное квантовое преобразование Фурье.
	\begin{verbatim}
def inversed_qft(n):
    qc = QuantumCircuit(n)
    for qubit in range(n//2):
        qc.swap(qubit, n-qubit-1)
    for j in range(n):
        for m in range(j):
            qc.cp(-np.pi/float(2**(j-m)), m, j)
        qc.h(j)
    qc.name = "QFT-1"
    return qc
	\end{verbatim}
	
	При помощи данных функций мы уже можем собрать схему квантовую схему нахождения периода. Функция \verb|shor_period| находит период квантовым алгоритмом Шора.
	\begin{verbatim}
    n_count = 8

    qc = QuantumCircuit(QuantumRegister(8,'x'),
                        QuantumRegister(4,'f(x)'),
                        ClassicalRegister(8))

    for q in range(n_count):
        qc.h(q)

    qc.x(3+n_count)

    for q in range(n_count):
        qc.append(c_amod15(2**q), [q] + [i+n_count for i in range(4)])

    qc.append(inversed_qft(n_count), range(n_count))
    qc.measure(range(n_count), range(n_count))
    print(qc)
    	\end{verbatim}

	Функция \verb|factorisation| реализует классическую часть алгоритма факторизации.
	
	Полный исходный код программы находится в приложении A.
	
	\newpage
	\anonsection{Заключение}
	В ходе практики мы усвоили принципы квантовых вычислений, изучили один из квантовых алгоритмов и рассмотрели его реализацию на языке python с использованием библиотеки qiskit.
	
	\newpage
	\include{tex/bibliography}
	\include{tex/add}
	
\end{document}